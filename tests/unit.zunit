#!/usr/bin/env zunit

@setup {
  load ../init.zsh
}

# 1
@test 'apply_highlights: empty input' {
  local -a region_highlight
  _zsh_easymotion_apply_highlights \
    "hello"                        \
    "" 
  assert "${#region_highlight[@]}" equals 1
  assert "$region_highlight[1]" same_as "0 5 fg=black,bold"
}

# 2
@test 'apply_highlights: single-character keys' {
  local -a region_highlight
  local -a map=(
    "a"$'\0'"2"
    "b"$'\0'"4"
  )
  _zsh_easymotion_apply_highlights \
    "x/x/x"                        \
    ""                             \
    ${map[@]}
  assert "${#region_highlight[@]}" equals 3
  assert "$region_highlight[1]" same_as "0 5 fg=black,bold"
  assert "$region_highlight[2]" same_as "1 2 fg=196,bold"
  assert "$region_highlight[3]" same_as "3 4 fg=196,bold"
}

# 3
@test 'apply_highlights: multi-character keys' {
  local -a region_highlight
  local -a map=("ab"$'\0'"2")
  _zsh_easymotion_apply_highlights \
    "x/xx"                         \
    ""                             \
    ${map[@]}
  assert "${#region_highlight[@]}" equals 3
  assert "$region_highlight[1]" same_as "0 4 fg=black,bold"
  assert "$region_highlight[2]" same_as "1 2 fg=208,bold"
  assert "$region_highlight[3]" same_as "2 3 fg=94,bold"
}

# 4
@test 'apply_highlights: mixed single and multi-char keys' {
  local -a region_highlight
  local -a maps=(
    "a"$'\0'"2"
    "bc"$'\0'"4"
  )
  _zsh_easymotion_apply_highlights \
    "x/x/xx"                       \
    ""                             \
    ${maps[@]}
  assert "${#region_highlight[@]}" equals 4
  assert "$region_highlight[1]" same_as "0 6 fg=black,bold"
  assert "$region_highlight[2]" same_as "1 2 fg=196,bold"
  assert "$region_highlight[3]" same_as "3 4 fg=208,bold"
  assert "$region_highlight[4]" same_as "4 5 fg=94,bold"
}

# 5
@test 'apply_highlights: respects custom zstyle colors' {
  zstyle ':zsh-easymotion:*' fg-primary 'fg=blue,bold'
  local -a region_highlight
  local -a map=(
    "a"$'\0'"2"
  )
  _zsh_easymotion_apply_highlights \
    "x/x"                          \
    ""                             \
    ${map[@]}
  assert "${#region_highlight[@]}" equals 2
  assert "$region_highlight[1]" same_as "0 3 fg=black,bold"
  assert "$region_highlight[2]" same_as "1 2 fg=blue,bold"
}

# 6
@test 'apply_replacements: empty keymap restores original buffer' {
  local BUFFER=""
  _zsh_easymotion_apply_replacements \
    "hello world"                    \
    ""
  assert "$BUFFER" same_as "hello world"
}

# 7
@test 'apply_replacements: single-character replacement' {
  local BUFFER=""
  local map=(
    "a"$'\0'"2"
  )
  _zsh_easymotion_apply_replacements \
    "x/x"                            \
    ""                               \
    ${map[@]}
  assert "$BUFFER" same_as "xax"
}

# 8
@test 'apply_replacements: multi-character replacement' {
  local BUFFER=""
  local map=(
    "ab"$'\0'"2"
  )
  _zsh_easymotion_apply_replacements \
    "x/xx"                           \
    ""                               \
    ${map[@]}
  assert "$BUFFER" same_as "xabx"
}

# 9
@test 'apply_replacements: multiple replacements applied' {
  local BUFFER=""
  local -a maps=(
    "a"$'\0'"2"
    ";a"$'\0'"4"
  )
  _zsh_easymotion_apply_replacements \
    "x/x/x"                          \
    ""                               \
    ${maps[@]}
  assert "$BUFFER" same_as "xax;a"
}

# 10
@test 'apply_replacements: overlapping replacements' {
  local BUFFER=""
  local -a maps=(
    ";a"$'\0'"2"
    ";b"$'\0'"3"
  )
  _zsh_easymotion_apply_replacements \
    "x//x"                           \
    ""                               \
    ${maps[@]}
  assert "$BUFFER" same_as "x;;b"
}

# 11
@test 'apply_replacements: end of buffer replacement' {
  local BUFFER=""
  local -a maps=(
    ";a"$'\0'"2"
  )
  _zsh_easymotion_apply_replacements \
    "x/"                             \
    ""                               \
    ${maps[@]}
  assert "$BUFFER" same_as "x;a"
}

# 12
@test 'assign_keys: empty indices returns empty keys' {
  local out
  _zsh_easymotion_assign_keys \
    ""                        \
    out
  assert "$out" is_empty
}

# 13
@test 'assign_keys: single target uses first key' {
  local out
  _zsh_easymotion_assign_keys \
    "10"                      \
    out
  assert "$out" same_as "a"
}

# 14
@test 'assign_keys: only single keys when enough' {
  # Default keys = a-z + ; → 27 keys
  local out
  _zsh_easymotion_assign_keys \
    "1 2 3 4 5"               \
    out
  assert "$out" same_as "a b c d e"
}

# 15
@test 'assign_keys: mixed single and double keys' {
  # Mock short key set for clarity
  zstyle ':zsh-easymotion:*' keys 'abc'
  
  local out
  _zsh_easymotion_assign_keys \
    "1 2 3 4 5 6"             \
    out
  
  # K=3, need P=2 → singles: [a], doubles: [ba bb bc ca cb cc]
  # Take first 6: a ba bb bc ca cb
  assert "$out" same_as "a ba bb bc ca cb"
  
  zstyle -d ':zsh-easymotion:*' keys
}

# 16
@test 'assign_keys: all double keys (max capacity)' {
  zstyle ':zsh-easymotion:*' keys 'ab'  # K=2, max=4
  
  local out
  _zsh_easymotion_assign_keys \
    "1 2 3 4"                 \
    out
  
  # P=2 → singles: none, doubles: [aa ab ba bb]
  assert "$out" same_as "aa ab ba bb"
  
  zstyle -d ':zsh-easymotion:*' keys
}

# 17
@test 'assign_keys: fails when target count exceeds capacity' {
  zstyle ':zsh-easymotion:*' keys 'ab'  # max=4
  
  local out
  run _zsh_easymotion_assign_keys \
    "1 2 3 4 5"                   \
    out
  assert $state equals 1

  zstyle -d ':zsh-easymotion:*' keys
}

# 18
@test 'assign_keys: respects custom key set from zstyle' {
  zstyle ':zsh-easymotion:*' keys 'xyz;'
  
  local out
  _zsh_easymotion_assign_keys \
    "1 2 3 4"                 \
    out
  assert "$out" same_as "x y z ;"
  
  zstyle -d ':zsh-easymotion:*' keys
}

# 19
@test 'boundaries: empty buffer' {
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    ""                       \
    out
  assert "$out" same_as ""

  _zsh_easymotion_boundaries \
    "end"                    \
    ""                       \
    out
  assert "$out" same_as ""
}

# 20
@test 'boundaries: basic words' {
  local out
  _zsh_easymotion_boundaries \
   "word"                    \
   "abc def ghi"             \
   out
  assert "$out" same_as "1 5 9"

  _zsh_easymotion_boundaries \
    "end"                    \
    "abc def ghi"            \
    out
  assert "$out" same_as "3 7 11"
}

# 21
@test 'boundaries: leading and trailing spaces' {
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    "  hello  world  "       \
    out
  assert "$out" same_as "3 10"

  _zsh_easymotion_boundaries \
    "end"                    \
    "  hello  world  "       \
    out
  assert "$out" same_as "7 14"
}

# 22
@test 'boundaries: punctuation as separators' {
  # Words: "foo", "bar_baz" (underscore is part of word!)
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    "foo.bar_baz"            \
    out
  assert "$out" same_as "1 5"

  _zsh_easymotion_boundaries \
    "end"                    \
    "foo.bar_baz"            \
    out
  assert "$out" same_as "3 11"
}

# 23
@test 'boundaries: alnum and underscore form words' {
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    "a1_b2 c3"               \
    out
  assert "$out" same_as "1 7"

  _zsh_easymotion_boundaries \
    "end"                    \
    "a1_b2 c3"               \
    out
  assert "$out" same_as "5 8"
}

# 24
@test 'boundaries: only non-word characters' {
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    "!!!   ... ;;;"          \
    out
  assert "$out" same_as ""

  _zsh_easymotion_boundaries \
    "end"                    \
    "!!!   ... ;;;"          \
    out
  assert "$out" same_as ""
}

# 25
@test 'boundaries: single-character words' {
  local out
  _zsh_easymotion_boundaries \
    "word"                   \
    "a b c"                  \
    out
  assert "$out" same_as "1 3 5"

  _zsh_easymotion_boundaries \
    "end"                    \
    "a b c"                  \
    out
  assert "$out" same_as "1 3 5"
}

# 26
@test 'build_keymap: empty input' {
  local out
  _zsh_easymotion_build_keymap \
  ""                           \
  out
  assert "$out" same_as ""
}

# 27
@test 'build_keymap: mock single entry' {
  function mock_assign_keys() {
    shift
    local output="$1"; shift
    : ${(P)output::="x"}
  }

  local _fn_assign_keys=mock_assign_keys
  local out
  _zsh_easymotion_build_keymap \
    "5"                        \
    out
  assert "$out" same_as "x"$'\0'"5"
}

# 28
@test 'build_keymap: mock multiple entries' {
  function mock_assign_keys() {
    shift
    local output="$1"; shift
    : ${(P)output::="x y"}
  }

  local _fn_assign_keys=mock_assign_keys
  local out
  _zsh_easymotion_build_keymap \
    "2 4"                      \
    out
  assert "$out" same_as "x"$'\0'"2 y"$'\0'"4"
}

# 29
@test 'build_keymap: mock multi-character keys' {
  function mock_assign_keys() {
    shift
    local output="$1"; shift
    : ${(P)output::="a b ;a ;b"}
  }

  local _fn_assign_keys=mock_assign_keys
  local out
  _zsh_easymotion_build_keymap \
    "3 5 7 11"                 \
    out

  local -a arr_out
  : ${(A)arr_out::=${(s. .)out}}
  assert "${#arr_out[@]}" equals 4
  assert "$arr_out[1]" same_as "a"$'\0'"3"
  assert "$arr_out[2]" same_as "b"$'\0'"5"
  assert "$arr_out[3]" same_as ";a"$'\0'"7"
  assert "$arr_out[4]" same_as ";b"$'\0'"11"
}

# 30
@test 'build_keymap: mock propagates assign_keys failure' {
  local _fn_assign_keys=_zsh_easymotion_failure

  local out
  run _zsh_easymotion_build_keymap \
    "1"                            \
    out
  assert $state equals 1
}

# 31
@test 'char2regex: default mode' {
  local out
  _zsh_easymotion_char2regex \
    'a'                      \
    out
  assert "$out" same_as 'a'

  _zsh_easymotion_char2regex \
    'A'                      \
    out
  assert "$out" same_as 'A'

  _zsh_easymotion_char2regex \
    '.'                      \
    out
  assert "$out" same_as '.'

  _zsh_easymotion_char2regex \
    '['                      \
    out
  assert "$out" same_as '\['

  _zsh_easymotion_char2regex \
    '1'                      \
    out
  assert "$out" same_as '1'
}

# 32
@test 'char2regex: ignorecase mode' {
  zstyle ':zsh-easymotion:*' search-case ignorecase

  local out
  _zsh_easymotion_char2regex \
    'a'                      \
    out
  assert "$out" same_as '[aA]'

  _zsh_easymotion_char2regex \
    'A'                      \
    out
  assert "$out" same_as '[aA]'

  _zsh_easymotion_char2regex \
    '.'                      \
    out
  assert "$out" same_as '.'

  _zsh_easymotion_char2regex \
    '['                      \
    out
  assert "$out" same_as '\['

  _zsh_easymotion_char2regex \
    '1'                      \
    out
  assert "$out" same_as '1'

  zstyle -d ':zsh-easymotion:*' search-case
}

# 33
@test 'char2regex: smartcase mode' {
  zstyle ':zsh-easymotion:*' search-case smartcase

  local out
  _zsh_easymotion_char2regex \
    'a'                      \
    out
  assert "$out" same_as '[aA]'

  _zsh_easymotion_char2regex \
    'A'                      \
    out
  assert "$out" same_as 'A'

  _zsh_easymotion_char2regex \
    '.'                      \
    out
  assert "$out" same_as '.'

  _zsh_easymotion_char2regex \
    '['                      \
    out
  assert "$out" same_as '\['

  _zsh_easymotion_char2regex \
    '1'                      \
    out
  assert "$out" same_as '1'

  zstyle -d ':zsh-easymotion:*' search-case
}

# 34
@test 'char2regex: regex metacharacters always escaped in literal context' {
  local out
  _zsh_easymotion_char2regex \
    '^'                      \
    out
  assert "$out" same_as '\^'

  _zsh_easymotion_char2regex \
    '|'                      \
    out
  assert "$out" same_as '\|'

  _zsh_easymotion_char2regex \
    '('                      \
    out
  assert "$out" same_as '\('

  _zsh_easymotion_char2regex \
    '['                      \
    out
  assert "$out" same_as '\['
}

# 35
@test 'failure: returns exit code 1' {
  run _zsh_easymotion_failure
  assert $state equals 1
}

# 36
@test 'handle_jump: fails when no targets' {
  run _zsh_easymotion_handle_jump \
    ""                            \
    ""
  assert $state equals 1
}

# 37
@test 'handle_jump: mock cancel jump' {
  local _fn_prompt_jump=_zsh_easymotion_failure
  local _fn_apply_replacement=":"
  local _fn_apply_replacement=":"

  run _zsh_easymotion_handle_jump \
    "abc"                         \
    ""                            \
    "a"$'\0'"5"                   \
    "b"$'\0'"6"

  assert $state equals 1
}

# 38
@test 'handle_jump: mock single target jumps directly' {
  local out
  function mock_move_cursor() {
    out="$1"
  }

  local _fn_move_cursor=mock_move_cursor
  _zsh_easymotion_handle_jump \
    "abc"                     \
    ""                        \
    "a"$'\0'"5"

  assert "$out" same_as "5"
}

# 39
@test 'handle_jump: mock recursive call with filtered keymaps' {
  local out
  function mock_move_cursor() {
    out="$1"
  }

  function mock_prompt_jump() {
    local output="$1"; shift
    : ${(P)output::="a"}
  }

  function zle() {}

  local _fn_apply_replacement=":"
  local _fn_apply_highlight=":"
  local _fn_prompt_jump=mock_prompt_jump
  local _fn_move_cursor=mock_move_cursor

  local -a maps=(
    ";a"$'\0'"11"
    ";b"$'\0'"13"
  )

  _zsh_easymotion_handle_jump \
    "buf"                     \
    ";"                       \
    ${maps[@]}

  assert "$out" same_as "11"
}

# 40
@test 'handle_jump: mock recursive call' {
  local out
  function mock_move_cursor() {
    out="$1"
  }

  local flag
  function mock_prompt_jump() {
    local output="$1"; shift

    if [[ -z "$flag" ]]; then
      : ${(P)output::=";"}
      flag=true
    else
      : ${(P)output::="b"}
    fi
  }

  function zle() {}

  local _fn_apply_replacement=":"
  local _fn_apply_highlight=":"
  local _fn_prompt_jump=mock_prompt_jump
  local _fn_move_cursor=mock_move_cursor

  local -a maps=(
    "a"$'\0'"7"
    ";a"$'\0'"11"
    ";b"$'\0'"13"
  )

  _zsh_easymotion_handle_jump \
    "buf"                     \
    ""                        \
    ${maps[@]}

  assert "$out" same_as "13"
}

# 41
@test 'handle_jump: typing unmatched key leads to failure' {
  local out
  function mock_move_cursor() {
    out="$1"
  }

  function mock_prompt_jump() {
    local output="$1"; shift
    : ${(P)output::="b"}
  }

  function zle() {}

  local _fn_apply_replacement=":"
  local _fn_apply_highlight=":"
  local _fn_prompt_jump=mock_prompt_jump
  local _fn_move_cursor=mock_move_cursor

  local -a maps=(
    "a"$'\0'"7"
    ";a"$'\0'"11"
    ";b"$'\0'"13"
  )

  run _zsh_easymotion_handle_jump \
    "buf"                         \
    ""                            \
    ${maps[@]}

  assert $state equals 1
}

# 42
@test 'isprintable: single printable char returns true' {
  run _zsh_easymotion_isprintable 'a'
  assert $state equals 0

  run _zsh_easymotion_isprintable 'Z'
  assert $state equals 0

  run _zsh_easymotion_isprintable '5'
  assert $state equals 0

  run _zsh_easymotion_isprintable '!'
  assert $state equals 0

  run _zsh_easymotion_isprintable ' '
  assert $state equals 0
}

# 43
@test 'isprintable: empty string returns false' {
  run _zsh_easymotion_isprintable ""
  assert $state equals 1
}

# 44
@test 'isprintable: control characters return false' {
  run _zsh_easymotion_isprintable $'\n'
  assert $state equals 1

  run _zsh_easymotion_isprintable $'\t'
  assert $state equals 1
  run _zsh_easymotion_isprintable $'\r'
  assert $state equals 1

  run _zsh_easymotion_isprintable $'\0'
  assert $state equals 1
}

# 45
@test 'jump_indices: boundaries with mock' {
  local called=0
  function mock_easymotion_boundaries() {
    called=1
    : ${(P)3::="1 7"}
  }

  local _fn_boundaries=mock_easymotion_boundaries
  local _fn_prompt=_zsh_easymotion_success
  local _fn_prompt_search=_zsh_easymotion_success
  local _fn_char2regex=_zsh_easymotion_success
  local _fn_match_indices=_zsh_easymotion_success

  local out
  _zsh_easymotion_jump_indices \
    "word"                     \
    "hello world"              \
    out
  assert "$called" same_as "1"
  assert "$out" same_as "1 7"

  called=0
  out=""
  _zsh_easymotion_jump_indices \
    "end"                      \
    "hello world"              \
    out
  assert "$called" same_as "1"
  assert "$out" same_as "1 7"
}

$ 46
@test 'match_indices: empty buffer returns empty' {
  local out
  _zsh_easymotion_match_indices \
    'x'                         \
    ""                          \
  out
  assert "$out" is_empty
}

# 47
@test 'match_indices: basic literal pattern' {
  local out
  _zsh_easymotion_match_indices \
    '/'                         \
    "a/b/c"                     \
    out
  assert "$out" same_as "2 4"
}

# 48
@test 'match_indices: no matches returns empty' {
  local out
  _zsh_easymotion_match_indices \
    'z'                         \
    "abc"                       \
    out
  assert "$out" is_empty
}

# 49
@test 'match_indices: matches at start and end' {
  local out
  _zsh_easymotion_match_indices \
    'a'                         \
    "abcba"                     \
    out
  assert "$out" same_as "1 5"
}

# 50
@test 'match_indices: regex metacharacters interpreted as pattern' {
  local out
  _zsh_easymotion_match_indices \
    "[aA]"                      \
    "An apple a day"            \
    out
  assert "$out" same_as "1 4 10 13"
}

# 51
@test 'match_indices: consecutive matches found correctly' {
  local out
  _zsh_easymotion_match_indices \
    'a'                         \
    "aaa"                       \
    out
  assert "$out" same_as "1 2 3"
}

# 52
@test 'move_cursor: converts 1-based to 0-based correctly' {
  local CURSOR

  _zsh_easymotion_move_cursor 1
  assert "$CURSOR" same_as "0"

  _zsh_easymotion_move_cursor 5
  assert "$CURSOR" same_as "4"

  _zsh_easymotion_move_cursor 10
  assert "$CURSOR" same_as "9"
}

# 53
@test 'prompt_jump: uses custom prompt from zstyle' {
  zstyle ':zsh-easymotion:*' prompt-key "Jump to> "

  local captured_prompt=""
  function mock_query_char() {
    captured_prompt="$2"
    : ${(P)1::="x"}  # mock user input
  }

  local _fn_query_char=mock_query_char

  local out
  _zsh_easymotion_prompt_jump out

  assert "$captured_prompt" same_as "Jump to> "
  assert "$out" same_as "x"

  zstyle -d ':zsh-easymotion:*' prompt-key
}

# 54
@test 'prompt_search: uses custom prompt from zstyle' {
  zstyle ':zsh-easymotion:*' prompt-char "Search > "

  local captured_prompt=""
  function mock_query_char() {
    captured_prompt="$2"
    : ${(P)1::="x"}  # mock user input
  }

  local _fn_query_char=mock_query_char

  local out
  _zsh_easymotion_prompt_search out

  assert "$captured_prompt" same_as "Search > "
  assert "$out" same_as "x"

  zstyle -d ':zsh-easymotion:*' prompt-char
}

# 55
@test 'readkey: fails on eof' {
  function read() {
    _zsh_easymotion_failure
  }

  local out
  run _zsh_easymotion_readkey out

  assert $state equals 1
}

# 56
@test 'readkey: not printable with mock' {
  function read() {
    local ref="$4"
    : ${(P)ref::="a"}  # mock user input
  }

  local _fn_isprintable=_zsh_easymotion_failure

  local out
  run _zsh_easymotion_readkey out

  assert $state equals 1
}

# 57
@test 'readkey: assign with mock' {
  function read() {
    local ref="$4"
    : ${(P)ref::="é"}  # mock user input
  }

  local _fn_isprintable=_zsh_easymotion_success

  local out
  _zsh_easymotion_readkey out

  assert "$out" same_as "é"
}

# 58
@test 'success: returns exit code 0' {
  run _zsh_easymotion_success
  assert $state equals 0
}
