#!/usr/bin/env zunit

@setup {
  load ../init.zsh
}

# 1
@test 'build_keymap: empty input' {
  local out
  _zsh_easymotion_build_keymap \
  ""                           \
  out
  assert "$out" same_as ""
}

# 2
@test 'build_keymap: single entry' {
  local out
  _zsh_easymotion_build_keymap \
    "5"                        \
    out
  local -a arr_out
  : ${(A)arr_out::=${(s. .)out}}
  assert "$out" same_as "a"$'\0'"5"
}

# 3
@test 'build_keymap: multiple entries' {
  local out
  _zsh_easymotion_build_keymap \
    "2 4"                      \
    out
  assert "$out" same_as "a"$'\0'"2 b"$'\0'"4"
}

# 4
@test 'build_keymap: multi-character keys' {
  local out
  _zsh_easymotion_build_keymap                                                  \
    "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28"\
    out
  assert "$out" same_as "a"$'\0'"1 b"$'\0'"2 c"$'\0'"3 d"$'\0'"4 e"$'\0'"5 \
f"$'\0'"6 g"$'\0'"7 h"$'\0'"8 i"$'\0'"9 j"$'\0'"10 k"$'\0'"11 l"$'\0'"12 \
m"$'\0'"13 n"$'\0'"14 o"$'\0'"15 p"$'\0'"16 q"$'\0'"17 r"$'\0'"18 s"$'\0'"19 \
t"$'\0'"20 u"$'\0'"21 v"$'\0'"22 w"$'\0'"23 x"$'\0'"24 y"$'\0'"25 z"$'\0'"26 \
;a"$'\0'"27 ;b"$'\0'"28"
}

# 5
@test 'build_keymap: propagates assign_keys failure' {
  zstyle ':zsh-easymotion:*' keys 'ab'  # max=4

  local out
  run _zsh_easymotion_build_keymap \
    "1 2 3 4 5"                    \
    out
  assert $state equals 1

  zstyle -d ':zsh-easymotion:*' keys
}

# 6
@test 'build_keymap: respects custom zstyle key' {
  zstyle ':zsh-easymotion:*' keys 'xyz'

  local out
  _zsh_easymotion_build_keymap \
    "3 5 7 11"                 \
    out

  local -a arr_out
  : ${(A)arr_out::=${(s. .)out}}
  assert "${#arr_out[@]}" equals 4
  assert "$arr_out[1]" same_as "x"$'\0'"3"
  assert "$arr_out[2]" same_as "y"$'\0'"5"
  assert "$arr_out[3]" same_as "zx"$'\0'"7"
  assert "$arr_out[4]" same_as "zy"$'\0'"11"

  zstyle -d ':zsh-easymotion:*' keys
}

# 7
@test 'handle_jump: single target jumps directly' {
  local CURSOR
  _zsh_easymotion_handle_jump \
    "abc"                     \
    ""                        \
    "a"$'\0'"5"

  assert "$CURSOR" same_as "4"
}

# 8
@test 'invoke: word mode' {
  zstyle ':zsh-easymotion:*' keys 'xyz'

  local out
  function mock_move_cursor() {
    out="$1"
  }

  local flag
  function mock_prompt_jump() {
    local output="$1"; shift

    if [[ -z "$flag" ]]; then
      : ${(P)output::="z"}
      flag=true
    else
      : ${(P)output::="x"}
    fi
  }

  function zle() {}

  local _fn_prompt_jump=mock_prompt_jump
  local _fn_move_cursor=mock_move_cursor

  _zsh_easymotion_invoke \
    "word"               \
    "Coffee fuels my day."
  
  assert "$out" same_as "14"

  zstyle -d ':zsh-easymotion:*' keys
}

# 9
@test 'invoke: end mode' {
  zstyle ':zsh-easymotion:*' keys 'xyz'

  local out
  function mock_move_cursor() {
    out="$1"
  }

  local flag
  function mock_prompt_jump() {
    local output="$1"; shift

    if [[ -z "$flag" ]]; then
      : ${(P)output::="z"}
      flag=true
    else
      : ${(P)output::="y"}
    fi
  }

  function zle() {}

  local _fn_prompt_jump=mock_prompt_jump
  local _fn_move_cursor=mock_move_cursor

  _zsh_easymotion_invoke \
    "end"                \
    "Coffee fuels my day."
  
  assert "$out" same_as "19"

  zstyle -d ':zsh-easymotion:*' keys
}

# 10
@test 'invoke: search mode' {
  zstyle ':zsh-easymotion:*' keys 'yz'  # max=4

  local out
  function mock_move_cursor() {
    out="$1"
  }

  local -i flag=0
  function mock_offer_keys() {
    local output="$1"; shift

    case $flag in
      0)
        : ${(P)output::="e"}
        ;;
      1)
        : ${(P)output::="z"}
        ;;
      2)
        : ${(P)output::="z"}
        ;;
    esac

    (( ++flag ))
  }

  function zle() {}

  local _fn_prompt_search=mock_offer_keys
  local _fn_prompt_jump=mock_offer_keys
  local _fn_move_cursor=mock_move_cursor

  _zsh_easymotion_invoke \
    "search"             \
    "Coffee fuels my day."
  
  assert "$out" same_as "10"

  zstyle -d ':zsh-easymotion:*' keys
}

# 11
@test 'jump_indices: word mode delegates to boundaries' {
  local out
  _zsh_easymotion_jump_indices \
    "word"                     \
    "hello world"              \
    out
  assert "$out" same_as "1 7"
}

# 12
@test 'jump_indices: end mode delegates to boundaries' {
  local out
  _zsh_easymotion_jump_indices \
    "end"                      \
    "hello world"              \
    out
  assert "$out" same_as "5 11"
}

# 13
@test 'jump_indices: search mode executes full pipeline' {
  local -i flag=0
  function mock_prompt_search() {
    local output="$1"; shift
    : ${(P)output::="e"}
  }

  local _fn_prompt_search=mock_prompt_search

  local out
  _zsh_easymotion_jump_indices \
    "search"                   \
    "Coffee fuels my day."     \
    out
  assert "$out" same_as "5 6 10"
}

# 14
@test 'jump_indices: search fails if match_indices fails' {
  local -i flag=0
  function mock_prompt_search() {
    local output="$1"; shift
    : ${(P)output::="!"}
  }

  local _fn_prompt_search=mock_prompt_search

  local out
  _zsh_easymotion_jump_indices \
    "search"                   \
    "Coffee fuels my day."     \
    out
  assert "$out" is_empty
}


# 15
@test 'protected_run: handles empty buffer gracefully' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER=""
  local CURSOR=0

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as ""
  assert $CURSOR equals 0
  assert $flag equals 0

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as ""
  assert $CURSOR equals 0
  assert $flag equals 0

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" is_empty
  assert $CURSOR equals 0
  assert $flag equals 0
}

# 16
@test 'protected_run: ignores whitespace-only buffer' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER="     "
  local CURSOR=3

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "     "
  assert $CURSOR equals 3
  assert $flag equals 0

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "     "
  assert $CURSOR equals 3
  assert $flag equals 0
}

# 17
@test 'protected_run: works with cursor at start of line' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="a"}
    (( ++flag ))
  }

  local BUFFER=" abc "
  local CURSOR=0

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 1
  assert $flag equals 0

  CURSOR=0
  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 3
  assert $flag equals 0

  CURSOR=0
  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 1
  assert $flag equals 1
}


# 18
@test 'protected_run: works with cursor at end of line' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="c"}
    (( ++flag ))
  }

  local BUFFER=" abc "
  local CURSOR=4

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 1
  assert $flag equals 0

  CURSOR=0
  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 3
  assert $flag equals 0

  CURSOR=0
  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as " abc "
  assert $CURSOR equals 3
  assert $flag equals 1
}

# 19
@test 'protected_run: handles single-character buffer correctly' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="x"}
    (( ++flag ))
  }

  local BUFFER="x"
  local CURSOR="0"

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "x"
  assert $CURSOR equals 0
  assert $flag equals 0

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "x"
  assert $CURSOR equals 0
  assert $flag equals 0

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "x"
  assert $CURSOR equals 0
  assert $flag equals 1
}

# 20
@test 'protected_run: word mode jumps to start of current word' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER="hello"
  local CURSOR=3

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "hello"
  assert $CURSOR equals 0
  assert $flag equals 0
}

# 21
@test 'protected_run: word mode targets next word when unambiguous' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="b"}
    (( ++flag ))
  }


  local BUFFER="foo bar"
  local CURSOR=5

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "foo bar"
  assert $CURSOR equals 4
  assert $flag equals 1
}

# 22
@test 'protected_run: word mode cycles through multiple matches' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        : ${(P)4::="b"}
        ;;
      2)
        : ${(P)4::="c"}
        ;;
    esac
    (( ++flag ))
  }


  local BUFFER="a/b/c"
  local CURSOR=5

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 0
  assert $flag equals 1

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 2
  assert $flag equals 2

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 4
  assert $flag equals 3
}

# 23
@test 'protected_run: word mode respects alphanumeric and underscore as word chars' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }


  local BUFFER="a_b_c"
  local CURSOR=5

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as "a_b_c"
  assert $CURSOR equals 0
  assert $flag equals 0
}

# 24
@test 'protected_run: word mode handles special symbols without error' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        : ${(P)4::="b"}
        ;;
      2)
        : ${(P)4::="c"}
        ;;
    esac
    (( ++flag ))
  }


  local BUFFER='a$b@c'
  local CURSOR=5

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as 'a$b@c'
  assert $CURSOR equals 0
  assert $flag equals 1

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as 'a$b@c'
  assert $CURSOR equals 2
  assert $flag equals 2

  _zsh_easymotion_protected_run "word"
  assert "$BUFFER" same_as 'a$b@c'
  assert $CURSOR equals 4
  assert $flag equals 3
}

# 25
@test 'protected_run: end mode jumps to end of single word' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER="hello"
  local CURSOR=3

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "hello"
  assert $CURSOR equals 4
  assert $flag equals 0
}

# 26
@test 'protected_run: end mode targets end of current word when clear' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="b"}
    (( ++flag ))
  }


  local BUFFER='Hi, there!'
  local CURSOR=9

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as 'Hi, there!'
  assert $CURSOR equals 8
  assert $flag equals 1
}

# 27
@test 'protected_run: end mode cycles through multiple word ends' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        : ${(P)4::="b"}
        ;;
      2)
        : ${(P)4::="c"}
        ;;
    esac
    (( ++flag ))
  }


  local BUFFER="a/b/c"
  local CURSOR=5

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 0
  assert $flag equals 1

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 2
  assert $flag equals 2

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 4
  assert $flag equals 3
}

# 28
@test 'protected_run: end mode stops at not trailing punctuation' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER='hello!!!'
  local CURSOR=3

  _zsh_easymotion_protected_run "end"
  assert "$BUFFER" same_as 'hello!!!'
  assert $CURSOR equals 4
  assert $flag equals 0
}

# 29
@test 'protected_run: search mode jumps to unique character match' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="b"}
    (( ++flag ))
  }

  local BUFFER="a/b/c"
  local CURSOR=5

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 2
  assert $flag equals 1
}

# 30
@test 'protected_run: search mode cycles through repeated character matches' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        : ${(P)4::="b"}
        ;;
    esac
    (( ++flag ))
  }

  local BUFFER="a/b/a"
  local CURSOR=2

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/a"
  assert $CURSOR equals 4
  assert $flag equals 2
}

# 31
@test 'protected_run: search mode aborts cleanly when no match found' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="x"}
    (( ++flag ))
  }

  local BUFFER="a/b/c"
  local CURSOR=2

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/c"
  assert $CURSOR equals 2
  assert $flag equals 1
}

# 32
@test 'protected_run: search mode handles Unicode characters safely' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::="üåç"}
    (( ++flag ))
  }

  local BUFFER="‰∏ñÁïåüåç,‰Ω†Â•Ω!"
  local CURSOR=6

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "‰∏ñÁïåüåç,‰Ω†Â•Ω!"
  assert $CURSOR equals 2
  assert $flag equals 1
}

# 33
@test 'protected_run: search mode finds whitespace characters' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::=" "}
        ;;
      1)
        : ${(P)4::="b"}
        ;;
    esac
    (( ++flag ))
  }

  local BUFFER="a b c"
  local CURSOR=4

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a b c"
  assert $CURSOR equals 3
  assert $flag equals 2
}

# 34
@test 'protected_run: search mode escapes shell metacharacters correctly' {
  function zle() {}

  local -i flag=0
  function read() {
    : ${(P)4::='['}
    (( ++flag ))
  }

  local BUFFER='Hello, [world]!'
  local CURSOR=4

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as 'Hello, [world]!'
  assert $CURSOR equals 7
  assert $flag equals 1
}

# 35
@test 'protected_run: search mode cancels on invalid user input' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        : ${(P)4::="c"}
        ;;
    esac
    (( ++flag ))
  }

  local BUFFER="a/b/a"
  local CURSOR=2

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/a"
  assert $CURSOR equals 2
  assert $flag equals 2
}

# 36
@test 'protected_run: search mode cancels on empty user input' {
  function zle() {}

  local -i flag=0
  function read() {
    case $flag in
      0)
        : ${(P)4::="a"}
        ;;
      1)
        ;;
    esac
    (( ++flag ))
  }

  local BUFFER="a/b/a"
  local CURSOR=2

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/a"
  assert $CURSOR equals 2
  assert $flag equals 2
}

# 37
@test 'protected_run: search mode cancels on empty user target' {
  function zle() {}

  local -i flag=0
  function read() {
    (( ++flag ))
  }

  local BUFFER="a/b/a"
  local CURSOR=2

  _zsh_easymotion_protected_run "search"
  assert "$BUFFER" same_as "a/b/a"
  assert $CURSOR equals 2
  assert $flag equals 1
}

# 38
@test 'readkey: printable ascii char' {
  function read() {
    local ref="$4"
    : ${(P)ref::="a"}  # mock user input
  }

  local out
  _zsh_easymotion_readkey out

  assert "$out" same_as "a"
}

# 39
@test 'readkey: printable unicode char' {
  function read() {
    local ref="$4"
    : ${(P)ref::="√©"}  # mock user input
  }

  local out
  _zsh_easymotion_readkey out

  assert "$out" same_as "√©"
}

# 40
@test 'readkey: rejects control character' {
  function read() {
    local ref="$4"
    : ${(P)ref::=$'\t'}  # mock user input
  }

  local out
  run _zsh_easymotion_readkey out

  assert $state equals 1
}

# 41
@test 'readkey: rejects multi characters' {
  function read() {
    local ref="$4"
    : ${(P)ref::="ab"}  # mock user input
  }

  local out
  run _zsh_easymotion_readkey out

  assert $state equals 1
}

